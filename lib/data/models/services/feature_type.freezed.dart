// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'feature_type.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$FeatureType {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() shopping,
    required TResult Function() ticketing,
    required TResult Function() service,
    required TResult Function() carrying,
    required TResult Function() display,
    required TResult Function() client_base,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? shopping,
    TResult? Function()? ticketing,
    TResult? Function()? service,
    TResult? Function()? carrying,
    TResult? Function()? display,
    TResult? Function()? client_base,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? shopping,
    TResult Function()? ticketing,
    TResult Function()? service,
    TResult Function()? carrying,
    TResult Function()? display,
    TResult Function()? client_base,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FeatureTypeShopping value) shopping,
    required TResult Function(FeatureTypeTicketing value) ticketing,
    required TResult Function(FeatureTypeService value) service,
    required TResult Function(FeatureTypeCarrying value) carrying,
    required TResult Function(FeatureTypeDisplay value) display,
    required TResult Function(FeatureTypeClientBase value) client_base,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FeatureTypeShopping value)? shopping,
    TResult? Function(FeatureTypeTicketing value)? ticketing,
    TResult? Function(FeatureTypeService value)? service,
    TResult? Function(FeatureTypeCarrying value)? carrying,
    TResult? Function(FeatureTypeDisplay value)? display,
    TResult? Function(FeatureTypeClientBase value)? client_base,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FeatureTypeShopping value)? shopping,
    TResult Function(FeatureTypeTicketing value)? ticketing,
    TResult Function(FeatureTypeService value)? service,
    TResult Function(FeatureTypeCarrying value)? carrying,
    TResult Function(FeatureTypeDisplay value)? display,
    TResult Function(FeatureTypeClientBase value)? client_base,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FeatureTypeCopyWith<$Res> {
  factory $FeatureTypeCopyWith(
          FeatureType value, $Res Function(FeatureType) then) =
      _$FeatureTypeCopyWithImpl<$Res, FeatureType>;
}

/// @nodoc
class _$FeatureTypeCopyWithImpl<$Res, $Val extends FeatureType>
    implements $FeatureTypeCopyWith<$Res> {
  _$FeatureTypeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$FeatureTypeShoppingCopyWith<$Res> {
  factory _$$FeatureTypeShoppingCopyWith(_$FeatureTypeShopping value,
          $Res Function(_$FeatureTypeShopping) then) =
      __$$FeatureTypeShoppingCopyWithImpl<$Res>;
}

/// @nodoc
class __$$FeatureTypeShoppingCopyWithImpl<$Res>
    extends _$FeatureTypeCopyWithImpl<$Res, _$FeatureTypeShopping>
    implements _$$FeatureTypeShoppingCopyWith<$Res> {
  __$$FeatureTypeShoppingCopyWithImpl(
      _$FeatureTypeShopping _value, $Res Function(_$FeatureTypeShopping) _then)
      : super(_value, _then);
}

/// @nodoc

class _$FeatureTypeShopping implements FeatureTypeShopping {
  const _$FeatureTypeShopping();

  @override
  String toString() {
    return 'FeatureType.shopping()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$FeatureTypeShopping);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() shopping,
    required TResult Function() ticketing,
    required TResult Function() service,
    required TResult Function() carrying,
    required TResult Function() display,
    required TResult Function() client_base,
  }) {
    return shopping();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? shopping,
    TResult? Function()? ticketing,
    TResult? Function()? service,
    TResult? Function()? carrying,
    TResult? Function()? display,
    TResult? Function()? client_base,
  }) {
    return shopping?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? shopping,
    TResult Function()? ticketing,
    TResult Function()? service,
    TResult Function()? carrying,
    TResult Function()? display,
    TResult Function()? client_base,
    required TResult orElse(),
  }) {
    if (shopping != null) {
      return shopping();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FeatureTypeShopping value) shopping,
    required TResult Function(FeatureTypeTicketing value) ticketing,
    required TResult Function(FeatureTypeService value) service,
    required TResult Function(FeatureTypeCarrying value) carrying,
    required TResult Function(FeatureTypeDisplay value) display,
    required TResult Function(FeatureTypeClientBase value) client_base,
  }) {
    return shopping(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FeatureTypeShopping value)? shopping,
    TResult? Function(FeatureTypeTicketing value)? ticketing,
    TResult? Function(FeatureTypeService value)? service,
    TResult? Function(FeatureTypeCarrying value)? carrying,
    TResult? Function(FeatureTypeDisplay value)? display,
    TResult? Function(FeatureTypeClientBase value)? client_base,
  }) {
    return shopping?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FeatureTypeShopping value)? shopping,
    TResult Function(FeatureTypeTicketing value)? ticketing,
    TResult Function(FeatureTypeService value)? service,
    TResult Function(FeatureTypeCarrying value)? carrying,
    TResult Function(FeatureTypeDisplay value)? display,
    TResult Function(FeatureTypeClientBase value)? client_base,
    required TResult orElse(),
  }) {
    if (shopping != null) {
      return shopping(this);
    }
    return orElse();
  }
}

abstract class FeatureTypeShopping implements FeatureType {
  const factory FeatureTypeShopping() = _$FeatureTypeShopping;
}

/// @nodoc
abstract class _$$FeatureTypeTicketingCopyWith<$Res> {
  factory _$$FeatureTypeTicketingCopyWith(_$FeatureTypeTicketing value,
          $Res Function(_$FeatureTypeTicketing) then) =
      __$$FeatureTypeTicketingCopyWithImpl<$Res>;
}

/// @nodoc
class __$$FeatureTypeTicketingCopyWithImpl<$Res>
    extends _$FeatureTypeCopyWithImpl<$Res, _$FeatureTypeTicketing>
    implements _$$FeatureTypeTicketingCopyWith<$Res> {
  __$$FeatureTypeTicketingCopyWithImpl(_$FeatureTypeTicketing _value,
      $Res Function(_$FeatureTypeTicketing) _then)
      : super(_value, _then);
}

/// @nodoc

class _$FeatureTypeTicketing implements FeatureTypeTicketing {
  const _$FeatureTypeTicketing();

  @override
  String toString() {
    return 'FeatureType.ticketing()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$FeatureTypeTicketing);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() shopping,
    required TResult Function() ticketing,
    required TResult Function() service,
    required TResult Function() carrying,
    required TResult Function() display,
    required TResult Function() client_base,
  }) {
    return ticketing();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? shopping,
    TResult? Function()? ticketing,
    TResult? Function()? service,
    TResult? Function()? carrying,
    TResult? Function()? display,
    TResult? Function()? client_base,
  }) {
    return ticketing?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? shopping,
    TResult Function()? ticketing,
    TResult Function()? service,
    TResult Function()? carrying,
    TResult Function()? display,
    TResult Function()? client_base,
    required TResult orElse(),
  }) {
    if (ticketing != null) {
      return ticketing();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FeatureTypeShopping value) shopping,
    required TResult Function(FeatureTypeTicketing value) ticketing,
    required TResult Function(FeatureTypeService value) service,
    required TResult Function(FeatureTypeCarrying value) carrying,
    required TResult Function(FeatureTypeDisplay value) display,
    required TResult Function(FeatureTypeClientBase value) client_base,
  }) {
    return ticketing(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FeatureTypeShopping value)? shopping,
    TResult? Function(FeatureTypeTicketing value)? ticketing,
    TResult? Function(FeatureTypeService value)? service,
    TResult? Function(FeatureTypeCarrying value)? carrying,
    TResult? Function(FeatureTypeDisplay value)? display,
    TResult? Function(FeatureTypeClientBase value)? client_base,
  }) {
    return ticketing?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FeatureTypeShopping value)? shopping,
    TResult Function(FeatureTypeTicketing value)? ticketing,
    TResult Function(FeatureTypeService value)? service,
    TResult Function(FeatureTypeCarrying value)? carrying,
    TResult Function(FeatureTypeDisplay value)? display,
    TResult Function(FeatureTypeClientBase value)? client_base,
    required TResult orElse(),
  }) {
    if (ticketing != null) {
      return ticketing(this);
    }
    return orElse();
  }
}

abstract class FeatureTypeTicketing implements FeatureType {
  const factory FeatureTypeTicketing() = _$FeatureTypeTicketing;
}

/// @nodoc
abstract class _$$FeatureTypeServiceCopyWith<$Res> {
  factory _$$FeatureTypeServiceCopyWith(_$FeatureTypeService value,
          $Res Function(_$FeatureTypeService) then) =
      __$$FeatureTypeServiceCopyWithImpl<$Res>;
}

/// @nodoc
class __$$FeatureTypeServiceCopyWithImpl<$Res>
    extends _$FeatureTypeCopyWithImpl<$Res, _$FeatureTypeService>
    implements _$$FeatureTypeServiceCopyWith<$Res> {
  __$$FeatureTypeServiceCopyWithImpl(
      _$FeatureTypeService _value, $Res Function(_$FeatureTypeService) _then)
      : super(_value, _then);
}

/// @nodoc

class _$FeatureTypeService implements FeatureTypeService {
  const _$FeatureTypeService();

  @override
  String toString() {
    return 'FeatureType.service()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$FeatureTypeService);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() shopping,
    required TResult Function() ticketing,
    required TResult Function() service,
    required TResult Function() carrying,
    required TResult Function() display,
    required TResult Function() client_base,
  }) {
    return service();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? shopping,
    TResult? Function()? ticketing,
    TResult? Function()? service,
    TResult? Function()? carrying,
    TResult? Function()? display,
    TResult? Function()? client_base,
  }) {
    return service?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? shopping,
    TResult Function()? ticketing,
    TResult Function()? service,
    TResult Function()? carrying,
    TResult Function()? display,
    TResult Function()? client_base,
    required TResult orElse(),
  }) {
    if (service != null) {
      return service();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FeatureTypeShopping value) shopping,
    required TResult Function(FeatureTypeTicketing value) ticketing,
    required TResult Function(FeatureTypeService value) service,
    required TResult Function(FeatureTypeCarrying value) carrying,
    required TResult Function(FeatureTypeDisplay value) display,
    required TResult Function(FeatureTypeClientBase value) client_base,
  }) {
    return service(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FeatureTypeShopping value)? shopping,
    TResult? Function(FeatureTypeTicketing value)? ticketing,
    TResult? Function(FeatureTypeService value)? service,
    TResult? Function(FeatureTypeCarrying value)? carrying,
    TResult? Function(FeatureTypeDisplay value)? display,
    TResult? Function(FeatureTypeClientBase value)? client_base,
  }) {
    return service?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FeatureTypeShopping value)? shopping,
    TResult Function(FeatureTypeTicketing value)? ticketing,
    TResult Function(FeatureTypeService value)? service,
    TResult Function(FeatureTypeCarrying value)? carrying,
    TResult Function(FeatureTypeDisplay value)? display,
    TResult Function(FeatureTypeClientBase value)? client_base,
    required TResult orElse(),
  }) {
    if (service != null) {
      return service(this);
    }
    return orElse();
  }
}

abstract class FeatureTypeService implements FeatureType {
  const factory FeatureTypeService() = _$FeatureTypeService;
}

/// @nodoc
abstract class _$$FeatureTypeCarryingCopyWith<$Res> {
  factory _$$FeatureTypeCarryingCopyWith(_$FeatureTypeCarrying value,
          $Res Function(_$FeatureTypeCarrying) then) =
      __$$FeatureTypeCarryingCopyWithImpl<$Res>;
}

/// @nodoc
class __$$FeatureTypeCarryingCopyWithImpl<$Res>
    extends _$FeatureTypeCopyWithImpl<$Res, _$FeatureTypeCarrying>
    implements _$$FeatureTypeCarryingCopyWith<$Res> {
  __$$FeatureTypeCarryingCopyWithImpl(
      _$FeatureTypeCarrying _value, $Res Function(_$FeatureTypeCarrying) _then)
      : super(_value, _then);
}

/// @nodoc

class _$FeatureTypeCarrying implements FeatureTypeCarrying {
  const _$FeatureTypeCarrying();

  @override
  String toString() {
    return 'FeatureType.carrying()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$FeatureTypeCarrying);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() shopping,
    required TResult Function() ticketing,
    required TResult Function() service,
    required TResult Function() carrying,
    required TResult Function() display,
    required TResult Function() client_base,
  }) {
    return carrying();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? shopping,
    TResult? Function()? ticketing,
    TResult? Function()? service,
    TResult? Function()? carrying,
    TResult? Function()? display,
    TResult? Function()? client_base,
  }) {
    return carrying?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? shopping,
    TResult Function()? ticketing,
    TResult Function()? service,
    TResult Function()? carrying,
    TResult Function()? display,
    TResult Function()? client_base,
    required TResult orElse(),
  }) {
    if (carrying != null) {
      return carrying();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FeatureTypeShopping value) shopping,
    required TResult Function(FeatureTypeTicketing value) ticketing,
    required TResult Function(FeatureTypeService value) service,
    required TResult Function(FeatureTypeCarrying value) carrying,
    required TResult Function(FeatureTypeDisplay value) display,
    required TResult Function(FeatureTypeClientBase value) client_base,
  }) {
    return carrying(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FeatureTypeShopping value)? shopping,
    TResult? Function(FeatureTypeTicketing value)? ticketing,
    TResult? Function(FeatureTypeService value)? service,
    TResult? Function(FeatureTypeCarrying value)? carrying,
    TResult? Function(FeatureTypeDisplay value)? display,
    TResult? Function(FeatureTypeClientBase value)? client_base,
  }) {
    return carrying?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FeatureTypeShopping value)? shopping,
    TResult Function(FeatureTypeTicketing value)? ticketing,
    TResult Function(FeatureTypeService value)? service,
    TResult Function(FeatureTypeCarrying value)? carrying,
    TResult Function(FeatureTypeDisplay value)? display,
    TResult Function(FeatureTypeClientBase value)? client_base,
    required TResult orElse(),
  }) {
    if (carrying != null) {
      return carrying(this);
    }
    return orElse();
  }
}

abstract class FeatureTypeCarrying implements FeatureType {
  const factory FeatureTypeCarrying() = _$FeatureTypeCarrying;
}

/// @nodoc
abstract class _$$FeatureTypeDisplayCopyWith<$Res> {
  factory _$$FeatureTypeDisplayCopyWith(_$FeatureTypeDisplay value,
          $Res Function(_$FeatureTypeDisplay) then) =
      __$$FeatureTypeDisplayCopyWithImpl<$Res>;
}

/// @nodoc
class __$$FeatureTypeDisplayCopyWithImpl<$Res>
    extends _$FeatureTypeCopyWithImpl<$Res, _$FeatureTypeDisplay>
    implements _$$FeatureTypeDisplayCopyWith<$Res> {
  __$$FeatureTypeDisplayCopyWithImpl(
      _$FeatureTypeDisplay _value, $Res Function(_$FeatureTypeDisplay) _then)
      : super(_value, _then);
}

/// @nodoc

class _$FeatureTypeDisplay implements FeatureTypeDisplay {
  const _$FeatureTypeDisplay();

  @override
  String toString() {
    return 'FeatureType.display()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$FeatureTypeDisplay);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() shopping,
    required TResult Function() ticketing,
    required TResult Function() service,
    required TResult Function() carrying,
    required TResult Function() display,
    required TResult Function() client_base,
  }) {
    return display();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? shopping,
    TResult? Function()? ticketing,
    TResult? Function()? service,
    TResult? Function()? carrying,
    TResult? Function()? display,
    TResult? Function()? client_base,
  }) {
    return display?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? shopping,
    TResult Function()? ticketing,
    TResult Function()? service,
    TResult Function()? carrying,
    TResult Function()? display,
    TResult Function()? client_base,
    required TResult orElse(),
  }) {
    if (display != null) {
      return display();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FeatureTypeShopping value) shopping,
    required TResult Function(FeatureTypeTicketing value) ticketing,
    required TResult Function(FeatureTypeService value) service,
    required TResult Function(FeatureTypeCarrying value) carrying,
    required TResult Function(FeatureTypeDisplay value) display,
    required TResult Function(FeatureTypeClientBase value) client_base,
  }) {
    return display(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FeatureTypeShopping value)? shopping,
    TResult? Function(FeatureTypeTicketing value)? ticketing,
    TResult? Function(FeatureTypeService value)? service,
    TResult? Function(FeatureTypeCarrying value)? carrying,
    TResult? Function(FeatureTypeDisplay value)? display,
    TResult? Function(FeatureTypeClientBase value)? client_base,
  }) {
    return display?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FeatureTypeShopping value)? shopping,
    TResult Function(FeatureTypeTicketing value)? ticketing,
    TResult Function(FeatureTypeService value)? service,
    TResult Function(FeatureTypeCarrying value)? carrying,
    TResult Function(FeatureTypeDisplay value)? display,
    TResult Function(FeatureTypeClientBase value)? client_base,
    required TResult orElse(),
  }) {
    if (display != null) {
      return display(this);
    }
    return orElse();
  }
}

abstract class FeatureTypeDisplay implements FeatureType {
  const factory FeatureTypeDisplay() = _$FeatureTypeDisplay;
}

/// @nodoc
abstract class _$$FeatureTypeClientBaseCopyWith<$Res> {
  factory _$$FeatureTypeClientBaseCopyWith(_$FeatureTypeClientBase value,
          $Res Function(_$FeatureTypeClientBase) then) =
      __$$FeatureTypeClientBaseCopyWithImpl<$Res>;
}

/// @nodoc
class __$$FeatureTypeClientBaseCopyWithImpl<$Res>
    extends _$FeatureTypeCopyWithImpl<$Res, _$FeatureTypeClientBase>
    implements _$$FeatureTypeClientBaseCopyWith<$Res> {
  __$$FeatureTypeClientBaseCopyWithImpl(_$FeatureTypeClientBase _value,
      $Res Function(_$FeatureTypeClientBase) _then)
      : super(_value, _then);
}

/// @nodoc

class _$FeatureTypeClientBase implements FeatureTypeClientBase {
  const _$FeatureTypeClientBase();

  @override
  String toString() {
    return 'FeatureType.client_base()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$FeatureTypeClientBase);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() shopping,
    required TResult Function() ticketing,
    required TResult Function() service,
    required TResult Function() carrying,
    required TResult Function() display,
    required TResult Function() client_base,
  }) {
    return client_base();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? shopping,
    TResult? Function()? ticketing,
    TResult? Function()? service,
    TResult? Function()? carrying,
    TResult? Function()? display,
    TResult? Function()? client_base,
  }) {
    return client_base?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? shopping,
    TResult Function()? ticketing,
    TResult Function()? service,
    TResult Function()? carrying,
    TResult Function()? display,
    TResult Function()? client_base,
    required TResult orElse(),
  }) {
    if (client_base != null) {
      return client_base();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FeatureTypeShopping value) shopping,
    required TResult Function(FeatureTypeTicketing value) ticketing,
    required TResult Function(FeatureTypeService value) service,
    required TResult Function(FeatureTypeCarrying value) carrying,
    required TResult Function(FeatureTypeDisplay value) display,
    required TResult Function(FeatureTypeClientBase value) client_base,
  }) {
    return client_base(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FeatureTypeShopping value)? shopping,
    TResult? Function(FeatureTypeTicketing value)? ticketing,
    TResult? Function(FeatureTypeService value)? service,
    TResult? Function(FeatureTypeCarrying value)? carrying,
    TResult? Function(FeatureTypeDisplay value)? display,
    TResult? Function(FeatureTypeClientBase value)? client_base,
  }) {
    return client_base?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FeatureTypeShopping value)? shopping,
    TResult Function(FeatureTypeTicketing value)? ticketing,
    TResult Function(FeatureTypeService value)? service,
    TResult Function(FeatureTypeCarrying value)? carrying,
    TResult Function(FeatureTypeDisplay value)? display,
    TResult Function(FeatureTypeClientBase value)? client_base,
    required TResult orElse(),
  }) {
    if (client_base != null) {
      return client_base(this);
    }
    return orElse();
  }
}

abstract class FeatureTypeClientBase implements FeatureType {
  const factory FeatureTypeClientBase() = _$FeatureTypeClientBase;
}
